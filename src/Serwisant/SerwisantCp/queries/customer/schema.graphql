# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: CustomerQuery
    mutation: CustomerMutation
}

type AcceptOrRejectRepairResult {
    errors: [Error!]
    success: Boolean!
}

type Address {
    ID: HashID!
    building: String!
    city: String!
    countryIso: String!
    postalCode: String!
    street: String!
    type: AddressType!
}

type CustomField {
    ID: HashID!
    concern: Dictionary
    description: String
    form: CustomFieldForm!
    name: String!
    required: Boolean!
    selectOptions: [String!]
    type: CustomFieldType!
}

type CustomFieldValue {
    "Primary key of particular field value to be used for update. NULL value means it's a field created after this entity creation."
    ID: HashID
    "Entity of field definition."
    field: CustomField!
    "Value of field for this particular object - it's always a string here - look into `field` definition to get proper casting."
    value: String
}

type Customer {
    address: Address
    addresses: [Address!]!
    "Customer agreements, including any new agreement customer should take (this is complete agreements list)"
    agreements: [CustomerAgreementValue!]!
    avatar: File
    companyName: String
    "Will return a list of values for custom fields"
    customFields: [CustomFieldValue!]!
    displayName: String
    email: String
    internetAccess: Boolean!
    isAnonymous: Boolean!
    person: String
    phone: Phone
    serviceSupplier: ServiceSupplier!
    taxId: String
    taxPrefix: TaxPrefix
    "Time zone of customer, all times wisible for customer should be represented in this time zone"
    timeZone: String!
    type: CustomerType!
}

type CustomerAgreement {
    ID: HashID!
    content: String
    description: String!
    "Agreement is required to create Customer, but only if corresponding do CustomerType visibility flag is enabled"
    required: Boolean!
    title: String!
    type: CustomerAgreementType!
    visibleBusiness: Boolean!
    visiblePersonal: Boolean!
}

type CustomerAgreementValue {
    "Primary key to be used to update agreement decision. NULL means this is a new created agreement and customer has no opportunity to make decision."
    ID: HashID
    "True mean customer accepted agreement"
    accepted: Boolean!
    "Entity of CustomerAgreement with all agreement details"
    agreement: CustomerAgreement!
}

type CustomerMutation {
    acceptOrRejectRepair(
        "Decision about a repair proposition. If any offers present, REJECT decision will reject all offers"
        decision: AcceptOrRejectRepairDecision!,
        "If offer ID passed (see RepairOffer entity), decision is made against particular offer"
        offer: HashID,
        repair: HashID!
    ): AcceptOrRejectRepairResult
    createMessage(message: MessageInput!): MessageCreationResult
    createMessageReply(content: String, message: HashID!): MessageReplyCreationResult
    "Create new repair as customer. Field `temporaryFiles` takes IDs of temporary files create via `createTemporaryFile `. Temporary files will be attached to repair and persisted."
    createRepair(additionalItems: [RepairItemInput!], repair: RepairInput!, temporaryFiles: [HashID!]): RepairCreationResult
    "Create a temporary file - file can be attached to created repair and will be persisted. It's useful to scenarios, where files must be uploaded before creation of eg. repair - and persisted with repair."
    createTemporaryFile(file: FileInput!): TemporaryFileCreationResult
    createTicket(temporaryFiles: [HashID!], ticket: TicketInput!): TicketCreationResult
    markMessageRead(message: HashID!): Boolean
    print(ID: HashID!, type: PrintType!): TemporaryFileCreationResult
    updateViewer(addresses: [AddressUpdateInput!], agreements: [CustomerAgreementUpdateInput!], customer: CustomerUpdateInput): ViewerUpdateResult
}

type CustomerQuery {
    autocomplete(query: String!, scope: AutocompleteScope!): [String!]!
    customFields(form: CustomFieldForm!): [CustomField!]!
    dictionaryEntries(filter: DictionaryEntriesFilter): [Dictionary!]!
    messages(filter: MessagesFilter = {type : ALL}, limit: Int = 20, page: Int = 1, sort: MessagesSort): MessagesResult!
    priorities(filter: PrioritiesFilter): [Priority!]!
    repairs(filter: RepairsFilter = {type : OPEN}, limit: Int = 20, page: Int = 1, sort: RepairsSort): RepairsResult!
    "Return details of temporary files identified by ID passed in arguments."
    temporaryFiles(ID: [HashID!]!): [TemporaryFile!]!
    tickets(filter: TicketsFilter = {type : OPEN}, limit: Int = 20, page: Int = 1, sort: TicketsSort = ID): TicketsResult!
    viewer: Viewer!
}

type Dictionary {
    ID: HashID!
    name: String!
    type: DictionaryType!
}

type Employee {
    displayName: String!
    serviceSupplier: ServiceSupplier!
}

"Error from mutation"
type Error {
    argument: String!
    code: String!
    message: String!
}

type File {
    contentType: String!
    image: Boolean!
    url(size: ImageSize = ORIGINAL): String
}

type Message {
    ID: HashID!
    content: String!
    createdAt: DateTime!
    sender: MessageSender!
    thread: MessageThread!
}

type MessageCreationResult {
    errors: [Error!]
    message: Message
}

type MessageRecipient {
    displayName: String!
    type: MessageRecipientType!
}

type MessageReplyCreationResult {
    errors: [Error!]
    message: Message
}

type MessageSender {
    displayName: String!
    type: MessageSenderType!
}

type MessageThread {
    ID: HashID!
    allMessages: Int!
    createdAt: DateTime!
    lastMessageAt: DateTime!
    messages: [Message!]!
    recipients: [MessageRecipient!]!
    subject: String
    unreadMessages: Int!
}

type MessagesResult {
    items: [MessageThread!]!
    pages: Int!
}

type Phone {
    "Country prefix, eg. +48"
    countryPrefix: String
    formatted: String
    isGsm: Boolean!
    "Number without country prefix - domestic number"
    number: String
}

type Priority {
    ID: HashID!
    color: String
    name: String!
    sla: Int
    type: PriorityType!
}

type Repair {
    ID: HashID!
    advanceAmount: Float!
    collectionType: RepairTransportType!
    costs: RepairCosts!
    "Will return a list of values for custom fields"
    customFields: [CustomFieldValue!]!
    deliveryType: RepairTransportType!
    diagnosis: RepairDiagnosis
    displayName: String!
    "Files attached to repair. For :service schema it includes private and public files, for otcher schemas only public files are included"
    files: [File!]!
    issue: String
    model: String
    offers: [RepairOffer!]
    priceEstimated: Float
    priceEstimatedTaxRate: Float
    rma: String!
    secretToken: SecretToken!
    serial: String
    "Service supplier who is currently processing this repair"
    serviceSupplier: ServiceSupplier!
    status: RepairStatus!
    summary: RepairSummary
    type: Dictionary!
    vendor: String
    warranty: Boolean!
    warrantyPurchaseDate: Date
    warrantyPurchaseDocument: String
}

type RepairCosts {
    estimatedGross: Money
    """

    Net price given in repair diagnosis, this is a price customer must confirm. If null, diagnosis wan't performed,
    no price given durring diagnosis or sepatate offers for this repair exists - see offer field
    """
    estimatedNet: Money
    finalGross: Money
    "Net price to be paid for repair"
    finalNet: Money
    "Full price (incl. tax) to be paid for whole service, decucted by advance, incremented by other possibe costs like shipping, etc."
    payment: Money
    proposedGross: Money
    "Net price proposed durring repair aquisition, nil if nothing was proposed, it's not a real price, rather a guess"
    proposedNet: Money
}

type RepairCreationResult {
    errors: [Error!]
    repair: Repair
}

type RepairDiagnosis {
    publicRemarks: String
}

type RepairOffer {
    ID: HashID!
    "This field can be null - that means no desision was made - true or false means yes or no"
    accepted: Boolean
    description: String
    items: [RepairOfferItem!]!
    number: String!
    priceGross: Float!
    "Summary net price for this offer. If offered repair was diagnosed, diagnosis price is included here."
    priceNet: Float!
    title: String!
}

type RepairOfferItem {
    description: String!
    priceGross: Float!
    priceNet: Float!
    type: RepairOfferItemType!
    vat: Float!
}

type RepairStatus {
    canceledOrRejected: Boolean!
    confirmed: Boolean!
    "Repair creation date - first apear in database"
    createdAt: DateTime!
    "Business days passed from startedAt date"
    daysFromStart: Int!
    "Business days to end of repair"
    daysToEnd: Int!
    diagnosed: Boolean!
    displayName: String!
    "This is estimated end date - this date is set by service once repair is created. It can differ from real `finishedAt`"
    finishDateEstimated: Date
    finished: Boolean!
    "Real date of repair finish. Finish mean transition into WAITING_FOR_COLLECTION or PASSED_FOR_RETURN state."
    finishedAt: Date
    progress: Float!
    requireCustomerAccept: Boolean!
    "Date when repair was started. For repair delivered by parcel or created via customer panel this will be set once repair will be delivered to service and its status will be set to WAITING_FOR_DIAGNOSIS"
    startedAt: Date
    status: RepairState!
    summedUp: Boolean!
    timeProgress: Float!
    timeStatus: OrderTimeStatus!
    "Date when repair was touched last time - repair update, status update, new diagnosis, repair acton will update this date"
    updatedAt: DateTime!
}

type RepairSummary {
    publicRemarks: String
}

type RepairsResult {
    items: [Repair!]!
    pages: Int!
}

type SecretToken {
    subjectType: SecretTokenSubject!
    token: String!
}

type ServiceSupplier {
    "Main address"
    address: Address
    "All given addresses, including a main one"
    addresses: [Address!]!
    avatar: File
    displayName: String!
    email: String
    phone: Phone
}

type TemporaryFile {
    ID: HashID!
    contentType: String!
    name: String!
    url(size: ImageSize = ORIGINAL): String
}

type TemporaryFileCreationResult {
    errors: [Error!]
    temporaryFile: TemporaryFile
}

type Ticket {
    ID: HashID!
    actions: [TicketAction!]!
    address: Address
    addressRemarks: String
    "Will return a list of values for custom fields"
    customFields: [CustomFieldValue!]!
    employee: Employee
    files: [File!]!
    issue: String!
    number: String!
    payment: TicketPayment!
    priority: Priority!
    status: TicketStatus!
    type: Dictionary
}

type TicketAction {
    hoursSpend: Decimal
    performedAt: DateTime!
    remarks: String
}

type TicketCreationResult {
    errors: [Error!]
    ticket: Ticket
}

type TicketPayment {
    amountGross: Money
    amountNet: Money
    hoursSpend: Decimal
    paid: Boolean!
    paymentGross: Money
    paymentNet: Money
    type: TicketPaymentType
}

type TicketStatus {
    createdAt: DateTime!
    "Human readeable status"
    displayName: String!
    "Real finish time, remarks are the same as for `started_on`"
    finishedAt: DateTime
    scheduledOn: DateTime
    scheduledTo: DateTime
    "Real start time based on status change - please note: if ticket status will not be updated or it will be updated post-factum date may be inaccurate"
    startedOn: DateTime
    "Ticket status as enum, use it to comparisons or other logic"
    status: TicketState!
}

type TicketsResult {
    items: [Ticket!]!
    pages: Int!
}

type Viewer {
    "Current customer"
    customer: Customer!
    "Service supplier dedicated for handling all repairs - it can be differ from main service supplier"
    repairsServiceSupplier: ServiceSupplier
    "Service supplier dedicated for handling ticketing - it can be differ from main service supplier"
    ticketsServiceSupplier: ServiceSupplier
}

type ViewerUpdateResult {
    errors: [Error!]
    viewer: Viewer
}

enum AcceptOrRejectRepairDecision {
    ACCEPT
    REJECT
}

enum AddressType {
    BILLING
    BUSINESS
    HOME
    OTHER
}

enum AutocompleteScope {
    MODEL
    VENDOR
}

enum CountryCode {
    PL
}

enum CustomFieldForm {
    CUSTOMER
    REPAIR
    TICKET
}

enum CustomFieldType {
    "Option"
    CHECKBOX
    "Date picker"
    DATE
    "Password (will be encrypted)"
    PASSWORD
    "Single choice list"
    SELECT
    "Single line text"
    TEXT
    "Multi line text"
    TEXTAREA
}

enum CustomerAgreementType {
    CUSTOM_1
    CUSTOM_2
    CUSTOM_3
    CUSTOM_4
    DATA_PROCESSING
    MARKETING_DATA_PROCESSING
    REFUND_POLICY
    RULES
}

enum CustomerType {
    "Company"
    BUSINESS
    "Person"
    PERSONAL
}

enum DictionaryType {
    "Type of component from inventory"
    COMPONENT_TYPE
    "Group od customers"
    CUSTOMER_GROUP
    "Repaired equipment types"
    REPAIR_SUBJECT_TYPE
    "Category of ticket"
    TICKET_CATEGORY
}

enum ImageSize {
    ORIGINAL
    THUMBNAIL
}

enum MessageRecipientType {
    CUSTOMER
    EMPLOYEE
    SERVICE_SUPPLIER
}

enum MessageSenderType {
    CUSTOMER
    EMPLOYEE
    SERVICE_SUPPLIER
}

enum MessagesFilterType {
    ALL
    ARCHIVED
    ID
}

enum MessagesSort {
    DATE_UPDATED
}

enum OrderTimeStatus {
    "Out of time"
    DELAYED
    "Inside agreed timespan"
    OK
    "Approaching to timespan border"
    WARNING
}

enum PrintType {
    REPAIR_INTRO
    REPAIR_SUMMARY
    TICKET
}

enum PriorityType {
    TICKET
}

enum RepairOfferItemType {
    "Diagnosis part, inserted in automated way if present"
    DIAGNOSIS
    "This is a part od offer"
    OFFER
}

enum RepairState {
    CANCELED
    CLOSED
    CONFIRMED
    DIAGNOSIS
    IN_PROGRESS
    NOT_ACCEPTED
    NOT_PROCESSABLE
    PASSED_FOR_RETURN
    REQ_CUSTOMER_ACCEPT
    REQ_SUMMARY
    SCRAPPED
    UNDER_TESTING
    UNSAVED
    WAITING_FOR_COLLECTION
    WAITING_FOR_DELIVERY
    WAITING_FOR_DIAGNOSIS
    WAITING_FOR_PARTS
}

enum RepairTransportType {
    "Repair will be delivered or returned-back by service employee"
    INTERNAL
    "Repair will be delivered or returned-back via parcel"
    PARCEL
    "Customer will deliver or pick-up repair by himself"
    PERSONAL
}

enum RepairsFilterType {
    "All repairs"
    ALL
    "Only expired repairs"
    EXPIRED
    "Repair with particular ID, ID argument required"
    ID
    "Only open repairs"
    OPEN
    "Search for repairs using keywords, argument q is required"
    SEARCH
    "Repairs in given status, status argument required"
    STATUS
}

enum RepairsSort {
    CUSTOMER
    "Creation date"
    DATE_CREATED
    DATE_STARTED
    DATE_STARTED_REV
    DATE_UPDATED
    DAYS_REMAINING
    RMA
    STATUS
}

enum SecretTokenSubject {
    LICENCE
    ONLINEPAYMENT
    PARCEL
    REPAIR
}

enum TaxPrefix {
    AT
    BE
    BG
    CY
    CZ
    DE
    DK
    EE
    EL
    ES
    FI
    FR
    GB
    HR
    HU
    IE
    IT
    LT
    LU
    LV
    MT
    NL
    PL
    PT
    RO
    SE
    SI
    SK
}

enum TicketPaymentType {
    CONTRACT
    INSTANT_FIXED
    INSTANT_TIME
    SUBSCRIPTION_FIXED
    SUBSCRIPTION_TIME
}

enum TicketState {
    ASSIGNED
    CANCELED
    IN_PROGRESS
    NEW
    ON_THE_WAY
    RESOLVED
    UNSAVED
}

enum TicketsFilterType {
    ALL
    ID
    OPEN
    SEARCH
    STATUS
}

enum TicketsSort {
    CREATED_AT
    ID
    STATUS
}

input AddressUpdateInput {
    ID: HashID
    building: String
    city: String
    countryIso: CountryCode
    postalCode: String
    street: String
    type: AddressType
}

input CustomFieldValueInput {
    "Field's primary key taken from customFields query"
    customField: HashID
    "Field's value relevant to definition - string, `1`/`0` for boolean or one of value from set (select)"
    value: String!
}

input CustomFieldValueUpdateInput {
    ID: HashID
    customField: HashID
    value: String!
}

input CustomerAgreementUpdateInput {
    ID: HashID
    accepted: Boolean!
    customerAgreement: HashID
}

input CustomerUpdateInput {
    companyName: String
    customFields: [CustomFieldValueUpdateInput!]
    email: String
    password: String
    person: String
    phone: PhoneInput
    taxId: String
    taxPrefix: TaxPrefix
    type: CustomerType
}

input DictionaryEntriesFilter {
    type: DictionaryType
}

input FileInput {
    "File MIME type, eg. image/png - must be valid IANA media type, list: http://www.iana.org/assignments/media-types/media-types.xhtml"
    contentType: String!
    "File name, only for display purposes"
    name: String!
    "File content encoded with base64. Please note: generic request size limit is always applied - whole mutation must be below 100MB"
    payload: String!
}

input MessageInput {
    content: String
    subject: String
}

input MessagesFilter {
    ID: HashID
    type: MessagesFilterType!
}

input PhoneInput {
    countryPrefix: String!
    number: String!
}

input PrioritiesFilter {
    type: PriorityType
}

input RepairInput {
    "How repair will be returned from service to customer"
    collection: RepairTransportType
    customFields: [CustomFieldValueInput!]
    "How repair will be delivered to service"
    delivery: RepairTransportType
    issue: String
    model: String
    "ID passed from one Address entity points to address where from repair will be picked up"
    pickUpAddress: HashID
    "ID passed from one Address entity points to address where repair will be returned"
    returnAddress: HashID
    serial: String
    "ID passed from one of REPAIR_SUBJECT_TYPE Dictionary entity"
    type: HashID!
    vendor: String
    warranty: Boolean
    warrantyPurchaseDate: Date
    warrantyPurchaseDocument: String
}

input RepairItemInput {
    description: String
    serial: String
    type: HashID!
}

input RepairsFilter {
    ID: HashID
    q: String
    status: RepairState
    type: RepairsFilterType!
}

input TicketInput {
    address: HashID
    addressOther: String
    customFields: [CustomFieldValueInput!]
    issue: String
    priority: HashID
    startAt: DateTime
    wantInvoice: Boolean
}

input TicketsFilter {
    ID: HashID
    q: String
    status: TicketState
    type: TicketsFilterType!
}


"An ISO 8601-encoded date, eg. 2000-01-01, YYYY-MM-DD"
scalar Date

"An ISO 8601-encoded datetime"
scalar DateTime

"Represents decimal."
scalar Decimal

"A reference to other, related entity or primary key of updated entity. 8 or more chars, uniq in scope of particular entity."
scalar HashID

"A decimal number represents amount of money."
scalar Money