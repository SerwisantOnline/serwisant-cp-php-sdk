# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: PublicQuery
    mutation: PublicMutation
}

type AcceptOrRejectRepairResult {
    errors: [Error!]
    success: Boolean!
}

type Address {
    building: String!
    city: String!
    countryIso: String!
    postalCode: String!
    street: String!
    type: AddressType!
}

type CustomField {
    ID: HashID!
    concern: Dictionary
    description: String
    name: String!
    required: Boolean!
    selectOptions: [String!]
    type: CustomFieldType!
}

type CustomFieldValue {
    "Primary key of particular field value to be used for update. NULL value means it's a field created after this entity creation."
    ID: HashID
    "Entity of field definition."
    field: CustomField!
    "Value of field for this particular object - it's always a string here - look into `field` definition to get proper casting."
    value: String
}

type CustomerActivationResult {
    errors: [Error!]
}

type CustomerAgreement {
    ID: HashID!
    content: String
    description: String!
    "Agreement is required to create Customer, but only if corresponding do CustomerType visibility flag is enabled"
    required: Boolean!
    title: String!
    type: CustomerAgreementType!
    visibleBusiness: Boolean!
    visiblePersonal: Boolean!
}

type CustomerCreationResult {
    errors: [Error!]
}

type CustomerPanelConfig {
    "Service currency, all API prices and other money values are in this currency"
    currency: Currency!
    "Message to be shown after login - only for authorised users"
    dashboardMessage: String
    internalTransportEnabled: Boolean!
    orderDictModel: Boolean!
    "True when service want to use a messaging system in customer panel"
    panelCommunication: Boolean!
    "Is access to customer panel enables"
    panelEnabled: Boolean!
    "True if service want to use repairs module"
    panelRepairs: Boolean!
    "True if service allow to customer self-register - False must disable signup possibility"
    panelSignups: Boolean!
    "True if service want to use ticketing module"
    panelTickets: Boolean!
    panelToken: String
    personalTransportEnabled: Boolean!
    requirePhoneNumber: Boolean!
    showOrderProgressInfo: Boolean!
    showRepairDelegation: Boolean!
    uploadOnlyImages: Boolean!
    "Message to be shown before login - for every user"
    welcomeMessage: String
}

type CustomerStatement {
    ID: HashID!
    content: String!
    title: String!
}

type Dictionary {
    name: String!
}

"Error from mutation"
type Error {
    argument: String!
    code: String!
    message: String!
}

type File {
    contentType: String!
    image: Boolean!
    url(size: ImageSize = ORIGINAL): String
}

type LoginResult {
    "Valid username"
    login: String!
    "Empty if credential can log in, otherwise list reasons prevent from log in"
    unavailabilityReasons: [LoginUnavailabilityReason!]!
}

type OnlinePayment {
    ID: HashID!
    "Full transacion amount, sum of items"
    amount: Money!
    "Amount to pay, amount reduced by already paid amounts"
    amountToPay: Money!
    currency: Currency!
    description: String
    items: [OnlinePaymentItem!]!
    number: String!
    "Branding name for service handling a payment, it's name communicated to customers on printouts, emails, etc"
    serviceSupplier: ServiceSupplier!
    status: OnlinePaymentStatus!
}

type OnlinePaymentChannel {
    ID: String!
    logo: File
    name: String!
}

type OnlinePaymentItem {
    amount: Money!
    description: String!
    secretToken: SecretToken
}

type OnlinePaymentMethod {
    channels: [OnlinePaymentChannel!]
    currency: Currency!
    type: OnlinePaymentMethodType!
}

type OnlinePaymentResult {
    errors: [Error!]
    onlineTransaction: OnlineTransaction
}

type OnlineTransaction {
    ID: HashID!
    processorUrl: String
    status: OnlineTransactionStatus!
}

type PasswordResetResult {
    errors: [Error!]
}

type PasswordSetResult {
    errors: [Error!]
}

type Phone {
    "Country prefix, eg. +48"
    countryPrefix: String
    formatted: String
    isGsm: Boolean!
    "Number without country prefix - domestic number"
    number: String
}

type PublicMutation {
    "Send there a customer decision regarding estimated repair costs"
    acceptOrRejectRepair(
        "Decision about a repair proposition. If any offers present, REJECT decision will reject all offers"
        decision: AcceptOrRejectRepairDecision!,
        "If offer ID passed (see RepairOffer entity), decision is made against particular offer"
        offer: HashID,
        "Repair token, the same was used to find repair."
        token: String!
    ): AcceptOrRejectRepairResult
    """

    Once customer is created via `createCustomer` he gets an email with activation URL contains a token.
    Token must be used against this mutation to activate an accoint and allo customer to log-in.
    """
    activateCustomer(activationToken: String!): CustomerActivationResult
    """

    Creates a customer account usable in `Customer` schema. Account is self-created account.
    Don't use it for purposes other than customer Panel sign-up.
    """
    createCustomer(addresses: [AddressInput!], agreements: [CustomerAgreementInput!], customer: CustomerInput!): CustomerCreationResult
    """

    Pay for `OnlinePayment` using any available `type` of payment. Depending on result status, payment may be
    queued: in that case pool for result, may be asked to redirect user to other site to complete a payment.
    """
    pay(errorUrl: String!, onlineTransaction: OnlineTransactionInput!, successUrl: String!, token: String!): OnlinePaymentResult
    """

    Give a login or email to get an email with password reset link. Email will contain a reset token to use with `setPassword` mutation.
    Token is valid for limited time.
    """
    resetPassword(loginOrEmail: String!, subject: PasswordResetSubject!): PasswordResetResult
    "Use a token sent by `resetPassword` to set a new password."
    setPassword(password: String!, passwordConfirmation: String!, resetToken: String!): PasswordSetResult
}

type PublicQuery {
    "Get a basic customer panel configuration options"
    configuration: CustomerPanelConfig!
    "List of agreements, eg. GDPR, rules, privacy policy to show/accept during a signup"
    customerAgreements(filter: CustomerAgreementsFilter): [CustomerAgreement!]!
    "Will return a list of custom fields for customer signup form - for generic list see customFields in other schemas"
    customerCustomFields: [CustomField!]!
    customerStatements: [CustomerStatement!]!
    "This query map given login credential, ie. email, or login itself to username valid for OAuth password login. Please note: given credential can point to more than one login, so thus must be handled on frontend side."
    login(loginCredential: String!): [LoginResult!]!
    "If token belongs to online payment, use this query to get details"
    paymentByToken(token: String!): OnlinePayment!
    """

    Return available payment methods for service related to access token. List can be empty, what mean service
    doesn't support online payments
    """
    paymentMethods: [OnlinePaymentMethod!]!
    paymentTransaction(ID: HashID!): OnlineTransaction!
    "Return detailed information about particular repair"
    repairByToken(token: String!): Repair!
    "Using this query you can lookup a token, to determine where it belongs, eg. order, or payment"
    secretToken(token: String!): SecretToken!
    "Information about a service, public registry name, address and branded name, address as well"
    viewer: Viewer!
}

type Repair {
    advanceAmount: Float!
    collectionType: RepairTransportType!
    costs: RepairCosts!
    "Will return a list of values for custom fields"
    customFields: [CustomFieldValue!]!
    deliveryType: RepairTransportType!
    diagnosis: RepairDiagnosis
    displayName: String!
    "Files attached to repair. For :service schema it includes private and public files, for otcher schemas only public files are included"
    files: [File!]!
    issue: String
    model: String
    offers: [RepairOffer!]
    priceEstimated: Float
    priceEstimatedTaxRate: Float
    rma: String!
    secretToken: SecretToken!
    serial: String
    "Service supplier who is currently processing this repair"
    serviceSupplier: ServiceSupplier!
    status: RepairStatus!
    summary: RepairSummary
    type: Dictionary!
    vendor: String
    warranty: Boolean!
    warrantyPurchaseDate: Date
    warrantyPurchaseDocument: String
}

type RepairCosts {
    estimatedGross: Money
    """

    Net price given in repair diagnosis, this is a price customer must confirm. If null, diagnosis wan't performed,
    no price given durring diagnosis or sepatate offers for this repair exists - see offer field
    """
    estimatedNet: Money
    finalGross: Money
    "Net price to be paid for repair"
    finalNet: Money
    "Full price (incl. tax) to be paid for whole service, decucted by advance, incremented by other possibe costs like shipping, etc."
    payment: Money
    proposedGross: Money
    "Net price proposed durring repair aquisition, nil if nothing was proposed, it's not a real price, rather a guess"
    proposedNet: Money
}

type RepairDiagnosis {
    publicRemarks: String
}

type RepairOffer {
    ID: HashID!
    "This field can be null - that means no desision was made - true or false means yes or no"
    accepted: Boolean
    description: String
    items: [RepairOfferItem!]!
    number: String!
    priceGross: Float!
    "Summary net price for this offer. If offered repair was diagnosed, diagnosis price is included here."
    priceNet: Float!
    title: String!
}

type RepairOfferItem {
    description: String!
    priceGross: Float!
    priceNet: Float!
    type: RepairOfferItemType!
    vat: Float!
}

type RepairStatus {
    canceledOrRejected: Boolean!
    confirmed: Boolean!
    "Repair creation date - first apear in database"
    createdAt: DateTime!
    "Business days passed from startedAt date"
    daysFromStart: Int!
    "Business days to end of repair"
    daysToEnd: Int!
    diagnosed: Boolean!
    displayName: String!
    "This is estimated end date - this date is set by service once repair is created. It can differ from real `finishedAt`"
    finishDateEstimated: Date
    finished: Boolean!
    "Real date of repair finish. Finish mean transition into WAITING_FOR_COLLECTION or PASSED_FOR_RETURN state."
    finishedAt: Date
    progress: Float!
    requireCustomerAccept: Boolean!
    "Date when repair was started. For repair delivered by parcel or created via customer panel this will be set once repair will be delivered to service and its status will be set to WAITING_FOR_DIAGNOSIS"
    startedAt: Date
    status: RepairState!
    summedUp: Boolean!
    timeProgress: Float!
    timeStatus: OrderTimeStatus!
    "Date when repair was touched last time - repair update, status update, new diagnosis, repair acton will update this date"
    updatedAt: DateTime!
}

type RepairSummary {
    publicRemarks: String
}

type SecretToken {
    subjectType: SecretTokenSubject!
    token: String!
}

type ServiceSupplier {
    "Main address"
    address: Address
    "All given addresses, including a main one"
    addresses: [Address!]!
    avatar: File
    displayName: String!
    email: String
    phone: Phone
}

type Subscriber {
    address: Address
    businessActivity: SubscriberBusinessActivity
    companyName: String
    "Formatted legal name"
    displayName: String!
    email: String!
    "Data of main service supplier - branded - this is a data for customer information"
    serviceSupplier: ServiceSupplier!
    taxId: String
    taxPrefix: TaxPrefix
}

type Viewer {
    "Information from public registry"
    subscriber: Subscriber!
}

enum AcceptOrRejectRepairDecision {
    ACCEPT
    REJECT
}

enum AddressType {
    BILLING
    BUSINESS
    HOME
    OTHER
}

enum CountryCode {
    AD
    AE
    AF
    AG
    AI
    AL
    AM
    AO
    AQ
    AR
    AS
    AT
    AU
    AW
    AX
    AZ
    BA
    BB
    BD
    BE
    BF
    BG
    BH
    BI
    BJ
    BL
    BM
    BN
    BO
    BQ
    BR
    BS
    BT
    BV
    BW
    BY
    BZ
    CA
    CC
    CD
    CF
    CG
    CH
    CI
    CK
    CL
    CM
    CN
    CO
    CR
    CU
    CV
    CW
    CX
    CY
    CZ
    DE
    DJ
    DK
    DM
    DO
    DZ
    EC
    EE
    EG
    EH
    ER
    ES
    ET
    FI
    FJ
    FK
    FM
    FO
    FR
    GA
    GB
    GD
    GE
    GF
    GG
    GH
    GI
    GL
    GM
    GN
    GP
    GQ
    GR
    GS
    GT
    GU
    GW
    GY
    HK
    HM
    HN
    HR
    HT
    HU
    ID
    IE
    IL
    IM
    IN
    IO
    IQ
    IR
    IS
    IT
    JE
    JM
    JO
    JP
    KE
    KG
    KH
    KI
    KM
    KN
    KP
    KR
    KW
    KY
    KZ
    LA
    LB
    LC
    LI
    LK
    LR
    LS
    LT
    LU
    LV
    LY
    MA
    MC
    MD
    ME
    MF
    MG
    MH
    MK
    ML
    MM
    MN
    MO
    MP
    MQ
    MR
    MS
    MT
    MU
    MV
    MW
    MX
    MY
    MZ
    NA
    NC
    NE
    NF
    NG
    NI
    NL
    NO
    NP
    NR
    NU
    NZ
    OM
    PA
    PE
    PF
    PG
    PH
    PK
    PL
    PM
    PN
    PR
    PS
    PT
    PW
    PY
    QA
    RE
    RO
    RS
    RU
    RW
    SA
    SB
    SC
    SD
    SE
    SG
    SH
    SI
    SJ
    SK
    SL
    SM
    SN
    SO
    SR
    SS
    ST
    SV
    SX
    SY
    SZ
    TC
    TD
    TF
    TG
    TH
    TJ
    TK
    TL
    TM
    TN
    TO
    TR
    TT
    TV
    TW
    TZ
    UA
    UG
    UM
    US
    UY
    UZ
    VA
    VC
    VE
    VG
    VI
    VN
    VU
    WF
    WS
    YE
    YT
    ZA
    ZM
    ZW
}

enum Currency {
    AED
    AFN
    ALL
    AMD
    ANG
    AOA
    ARS
    AUD
    AWG
    AZN
    BAM
    BBD
    BDT
    BGN
    BHD
    BIF
    BMD
    BND
    BOB
    BRL
    BSD
    BTN
    BWP
    BYR
    BZD
    CAD
    CDF
    CHF
    CLP
    CNY
    COP
    CRC
    CUP
    CVE
    CZK
    DJF
    DKK
    DOP
    DZD
    EEK
    EGP
    ETB
    EUR
    FJD
    FKP
    GBP
    GEL
    GGP
    GHS
    GIP
    GMD
    GNF
    GTQ
    GYD
    HKD
    HNL
    HRK
    HTG
    HUF
    IDR
    ILS
    IMP
    INR
    IQD
    IRR
    ISK
    JEP
    JMD
    JOD
    JPY
    KES
    KGS
    KHR
    KMF
    KPW
    KRW
    KWD
    KYD
    KZT
    LAK
    LBP
    LKR
    LRD
    LSL
    LTL
    LVL
    LYD
    MAD
    MDL
    MGA
    MKD
    MMK
    MNK
    MNT
    MRO
    MUR
    MVR
    MWK
    MXN
    MYR
    MZN
    NAD
    NGN
    NIO
    NOK
    NPR
    NZD
    OMR
    PAB
    PEN
    PGK
    PHP
    PKR
    PLN
    PYG
    QAR
    RON
    RSD
    RUB
    RWF
    SAR
    SBD
    SCR
    SDG
    SEK
    SGD
    SHP
    SLL
    SOS
    SRD
    STD
    SVC
    SYP
    SZL
    THB
    TJS
    TMM
    TND
    TOP
    TRY
    TTD
    TVD
    TWD
    TZS
    UAH
    UGX
    USD
    UYU
    UZS
    VEF
    VND
    XAF
    XCD
    XOF
    XPF
    YER
    ZAR
    ZMK
    ZWD
}

enum CustomFieldType {
    "Option"
    CHECKBOX
    "Date picker"
    DATE
    "Password (will be encrypted)"
    PASSWORD
    "Single choice list"
    SELECT
    "Single line text"
    TEXT
    "Multi line text"
    TEXTAREA
}

enum CustomerAgreementType {
    CUSTOM_1
    CUSTOM_2
    CUSTOM_3
    CUSTOM_4
    DATA_PROCESSING
    MARKETING_DATA_PROCESSING
    REFUND_POLICY
    RULES
}

enum CustomerType {
    "Company"
    BUSINESS
    "Person"
    PERSONAL
}

enum ImageSize {
    ORIGINAL
    THUMBNAIL
}

enum LoginUnavailabilityReason {
    DELETED
    DISABLED
    NOT_ACTIVATED
}

enum OnlinePaymentMethodType {
    BLIK
    TRANSFER
}

enum OnlinePaymentStatus {
    PAID
    UNPAID
    WAITING_FOR_PAYMENT
}

enum OnlineTransactionStatus {
    "Brand new transaction, not submitted to payment processor yet, pool for result using query `paymentTransaction`"
    CREATED
    FAILED
    "Transaction was submitted and will be processed asynchronously, pool for result using query `paymentTransaction`"
    POOL
    """

    Transaction was submitted but require redirection first, eg. for bank login, or 3DS authorisation, next must
    be pooled. Please note, when customer come back from redirect, transaction status probably won't change - it's
    processed asynchronously - it's on your side to care about to pool not to redirect again. Hint: use `successUrl`
    and `errorUrl` at `pay` mutation to pass data.
    """
    REDIRECT_POOL
    REFUNDED
    SUCCESSFUL
}

enum OrderTimeStatus {
    "Out of time"
    DELAYED
    "Inside agreed timespan"
    OK
    "Approaching to timespan border"
    WARNING
}

enum PasswordResetSubject {
    CUSTOMER
}

enum RepairOfferItemType {
    "Diagnosis part, inserted in automated way if present"
    DIAGNOSIS
    "This is a part od offer"
    OFFER
}

enum RepairState {
    CANCELED
    CLOSED
    CONFIRMED
    DIAGNOSIS
    IN_PROGRESS
    NOT_ACCEPTED
    NOT_PROCESSABLE
    PASSED_FOR_RETURN
    REQ_CUSTOMER_ACCEPT
    REQ_SUMMARY
    SCRAPPED
    UNDER_TESTING
    UNSAVED
    WAITING_FOR_COLLECTION
    WAITING_FOR_DELIVERY
    WAITING_FOR_DIAGNOSIS
    WAITING_FOR_PARTS
}

enum RepairTransportType {
    "Repair will be delivered or returned-back by service employee"
    INTERNAL
    "Repair will be delivered or returned-back via parcel"
    PARCEL
    "Customer will deliver or pick-up repair by himself"
    PERSONAL
}

enum SecretTokenSubject {
    LICENCE
    ONLINEPAYMENT
    PARCEL
    REPAIR
}

enum SubscriberBusinessActivity {
    BIKES
    CELL_PHONE
    ELECTRONIC
    HOUSEHOLD_EQUIPMENT
    OTHER
    PC
}

enum TaxPrefix {
    AT
    BE
    BG
    CY
    CZ
    DE
    DK
    EE
    EL
    ES
    FI
    FR
    GB
    HR
    HU
    IE
    IT
    LT
    LU
    LV
    MT
    NL
    PL
    PT
    RO
    SE
    SI
    SK
}

input AddressInput {
    building: String
    city: String
    countryIso: CountryCode
    postalCode: String
    street: String
    type: AddressType
}

input CustomFieldValueInput {
    "Field's primary key taken from customFields query"
    customField: HashID
    "Field's value relevant to definition - string, `1`/`0` for boolean or one of value from set (select)"
    value: String!
}

input CustomerAgreementInput {
    "True id customer accepts agreement"
    accepted: Boolean!
    "Agreement's primary key taken from customerAgreements query"
    customerAgreement: HashID
}

input CustomerAgreementsFilter {
    ID: HashID
    types: [CustomerAgreementType!]
}

input CustomerInput {
    companyName: String
    customFields: [CustomFieldValueInput!]
    email: String
    login: String
    password: String
    person: String
    phone: PhoneInput
    taxId: String
    taxPrefix: TaxPrefix
    type: CustomerType
}

input OnlineTransactionAgreementsInput {
    dataProcessing: Boolean!
    payment: Boolean!
}

input OnlineTransactionInput {
    agreements: OnlineTransactionAgreementsInput!
    channel: String
    code: String
    payer: OnlineTransactionPayerInput
    type: OnlinePaymentMethodType!
}

input OnlineTransactionPayerInput {
    email: String!
    name: String!
}

input PhoneInput {
    countryPrefix: String!
    number: String!
}


"An ISO 8601-encoded date, eg. 2000-01-01, YYYY-MM-DD"
scalar Date

"An ISO 8601-encoded datetime"
scalar DateTime

"A reference to other, related entity or primary key of updated entity. 8 or more chars, uniq in scope of particular entity."
scalar HashID

"A decimal number represents amount of money."
scalar Money